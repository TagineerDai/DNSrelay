#!/usr/bin/env python# coding: utf-8import ConfigParserimport osimport reimport ourdnslibimport loggingimport sysimport threadingfrom cache import DNSCachefrom socket import *import osimport loggingimport socketfrom optparse import OptionParserimport multiprocessing# socket parameterForeignIP = "10.3.9.4"  # foreign serverLocalIP = "192.168.0.1"  # localhost# What are the two ip for?ForeignPort = 53Port = 53BufferSize = 512# cache parametercache = NoneCacheSize = 200DNSFile = "dnsrelay.txt"LDT = 600  # second# test parameterdbg_level = 0# 0--(empty) | 1--(-d) | 2--(-dd)def debug(string):    global dbg_level    if dbg_level >= 1:        print stringdef ddebug(string):    global dbg_level    if dbg_level >= 2:        print stringdef arg_parser():    """The config argument parser for DNS relay program."""    _dbglevel = 1    _name_server = "192.168.0.1"    _DNSFile = "dnsrelay.txt"    _LDT = 600    _CacheSize = 2000    _BufferSize = 512    try:        parser = OptionParser()        parser.add_option('-d', dest='_dbglevel', type='int', default=0, help='The debug info level')        parser.add_option('-s', dest='_name_server', type='string', default='192.168.0.1', help='The name server')        parser.add_option('-f', dest='_DNSFile', type='string', default='dnsrelay.txt', help='DNSFile')        parser.add_option('-t', dest='_LDT', type='int', default=600, help='DwellingTime')        parser.add_option('-c', dest='_CacheSize', type='int', default=200, help='CacheSize')        parser.add_option('-b', dest='_BufferSize', type='int', default=512, help='BufferSize')        (options, args) = parser.parse_args()        # -d        if options._dbglevel > 2:            _dbglevel = 2        elif options._dbglevel < 0:            _dbglevel = 0        else :            _dbglevel = options._dbglevel        # -s        _name_server = options._name_server        # -f        _DNSFile = options._DNSFile        if not os.path.exists(_DNSFile):            f = open(_DNSFile, 'w')            f.close()        # -t        _LDT = options._LDT        if _LDT < 0:            _LDT = 600        # -c        _CacheSize = options._CacheSize        if _CacheSize < 0:            _CacheSize = 2000        # -b        _BufferSize = options._BufferSize        if _BufferSize < 1:            _BufferSize = 512    except Exception as ex:        print("Exception :{0}".format(str(ex)))    return _dbglevel, _name_server, _DNSFile, _LDT, _CacheSize, _BufferSizedef query(qname):    global ForeignIP, ForeignPort    d = ourdnslib.DNSRecord.question(qname)    return d.send(ForeignIP, 53, False, 5.0, False)def resolve(dns, addr, sock, data):    global cache    dns.header.set_qr(ourdnslib.QR.RESPONSE)    # 获得请求域名    rd = dns.header.get_rd()    qname = dns.q.qname    sqname = str(qname).strip('.')    if cache.exist(sqname):        ip = cache.get(sqname)        ddebug("Query qname=%r, eixt in cache"%sqname)        ddebug("ip=%r"%ip)        if ip is not None:            if ip == "0.0.0.0":                sock.sendto(dns.pack(), addr)            else:                dns.add_answer(ourdnslib.RR(qname, ourdnslib.QTYPE.A, rdata=ourdnslib.A(ip), ttl=0))                sock.sendto(dns.pack(), addr)        else:            ddebug("error, exist in cache, but get none")            sock.sendto(dns.pack(), addr)    else:        ddebug("Query qname=%r, doesn't exit in cache, "%sqname)        if rd != 0:            # 递归模式            ddebug("rd=1,request from foreign server")            foreign_res = query(sqname)            if foreign_res == None:                # UDP 超时， 仅将request的qr 改为resonse，其他不变，原封不动返回                ddebug("Foreign UDP timeout, question id = %r"%dns.header.id)                sock.sendto(dns.pack(), addr)            else:                # 外部请求成功， 把外部请求的 response id 改一下就可以直接返回了                res = ourdnslib.DNSRecord.parse(foreign_res)                ddebug("foreign_res=%r"%(str(res)))                dns.add_answer(res.get_a())                sock.sendto(dns.pack(), addr)        else:            #非递归模式， 返回foreign ip            ddebug("rd=0, return foreign ip")            qq = ourdnslib.DNSRecord.question(qname)            a = qq.reply()            a.add_answer(ourdnslib.RR(qname, ourdnslib.QTYPE.NS, rdata=ourdnslib.NS(ForeignIP), ttl=60))            sock.sendto(a.pack(), addr)def handle(data, address, connection):    import time    time = time.time()    if data == "":        debug("Time: %r, get a empty request."%(time))    try:        dns = ourdnslib.DNSRecord.parse(data)    except Exception as e:        print 'Not a DNS packet.\n', e    else:        debug("Time: %r, no = %r, ip = %r , q = %r"%(time, dns.header.id, address, str(dns.q.qname)))        resolve(dns, address, connection, data)    connection.close()class Server(object):    def __init__(self, hostname, port):        self.logger = logging.getLogger("Server")        self.hostname = hostname        self.port = port    def start(self):        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        self.socket.bind((self.hostname, self.port))        while True:            data, address = self.socket.recvfrom(1024)            process = multiprocessing.Process(target=handle, args=(data, address, self.socket))            process.daemon = True            process.start()if __name__ == "__main__":    user_argvs = {}    #sys.argv    dbg_level, name_server, DNSFile, LDT, CacheSize, BufferSize = arg_parser()    cache = DNSCache(DNSFile, CacheSize, LDT)    logging.basicConfig(level=logging.DEBUG)    server = Server("127.0.0.1", 53)    try:        print("Listening")        server.start()    except:        print("Unexpected exception")    finally:        print("Shutting down")        for process in multiprocessing.active_children():            print("Shutting down process %r", process)            process.terminate()            process.join()    print("All done")